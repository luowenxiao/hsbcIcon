// components/__tests__/FileUpload.test.tsx
import React from 'react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import FileUpload from '../FileUpload';

// æ¨¡æ‹Ÿæ–‡ä»¶å¯¹è±¡
const createMockFile = (name: string, size: number, type: string): File => {
  const file = new File([''], name, { type });
  Object.defineProperty(file, 'size', { value: size });
  return file;
};

// æ¨¡æ‹Ÿæ‹–æ‹½äº‹ä»¶æ•°æ®
const createDragEventData = (files: File[]) => ({
  dataTransfer: {
    files,
    items: files.map(file => ({
      kind: 'file',
      type: file.type,
      getAsFile: () => file
    })),
    types: ['Files']
  }
});

describe('FileUpload', () => {
  const mockOnFilesChange = vi.fn();

  beforeEach(() => {
    mockOnFilesChange.mockClear();
  });

  describe('åŸºç¡€æ¸²æŸ“', () => {
    it('åº”è¯¥æ­£ç¡®æ¸²æŸ“ä¸Šä¼ åŒºåŸŸ', () => {
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      expect(screen.getByText(/æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ /)).toBeInTheDocument();
      expect(screen.getByText('é€‰æ‹©æ–‡ä»¶')).toBeInTheDocument();
    });

    it('åº”è¯¥æ˜¾ç¤ºæ–‡ä»¶è¦æ±‚ä¿¡æ¯', () => {
      render(
        <FileUpload 
          accept="image/*" 
          maxSize={5242880} 
          onFilesChange={mockOnFilesChange} 
        />
      );
      
      expect(screen.getByText(/æ”¯æŒ image\*/)).toBeInTheDocument();
      expect(screen.getByText(/æœ€å¤§ 5 MB/)).toBeInTheDocument();
    });

    it('å•æ–‡ä»¶æ¨¡å¼åº”è¯¥æ˜¾ç¤ºæ­£ç¡®çš„æç¤ºæ–‡å­—', () => {
      render(<FileUpload multiple={false} onFilesChange={mockOnFilesChange} />);
      
      expect(screen.getByText(/æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶/)).toBeInTheDocument();
    });
  });

  describe('æ–‡ä»¶é€‰æ‹©åŠŸèƒ½', () => {
    it('åº”è¯¥é€šè¿‡ç‚¹å‡»é€‰æ‹©æ–‡ä»¶', async () => {
      const user = userEvent.setup();
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const file = createMockFile('test.png', 1024, 'image/png');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, file);
      
      expect(mockOnFilesChange).toHaveBeenCalledWith([
        expect.objectContaining({
          name: 'test.png',
          size: 1024,
          type: 'image/png'
        })
      ]);
    });

    it('åº”è¯¥æ”¯æŒå¤šæ–‡ä»¶é€‰æ‹©', async () => {
      const user = userEvent.setup();
      render(<FileUpload multiple onFilesChange={mockOnFilesChange} />);
      
      const files = [
        createMockFile('test1.png', 1024, 'image/png'),
        createMockFile('test2.jpg', 2048, 'image/jpeg')
      ];
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, files);
      
      expect(mockOnFilesChange).toHaveBeenCalledWith([
        expect.objectContaining({ name: 'test1.png' }),
        expect.objectContaining({ name: 'test2.jpg' })
      ]);
    });

    it('å•æ–‡ä»¶æ¨¡å¼åº”è¯¥åªä¿ç•™æœ€åä¸€ä¸ªæ–‡ä»¶', async () => {
      const user = userEvent.setup();
      render(<FileUpload multiple={false} onFilesChange={mockOnFilesChange} />);
      
      const files = [
        createMockFile('test1.png', 1024, 'image/png'),
        createMockFile('test2.jpg', 2048, 'image/jpeg')
      ];
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, files);
      
      // åº”è¯¥åªä¿ç•™æœ€åä¸€ä¸ªæ–‡ä»¶
      expect(mockOnFilesChange).toHaveBeenCalledWith([
        expect.objectContaining({ name: 'test2.jpg' })
      ]);
    });
  });

  describe('æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½', () => {
    it('åº”è¯¥å¤„ç†æ–‡ä»¶æ‹–æ‹½ä¸Šä¼ ', async () => {
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const dropzone = screen.getByText(/æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ /).closest('div')!;
      const file = createMockFile('dragged.png', 1024, 'image/png');
      
      // è§¦å‘æ‹–æ‹½è¿›å…¥
      fireEvent.dragEnter(dropzone);
      expect(dropzone).toHaveClass('active');
      
      // è§¦å‘æ‹–æ‹½æ”¾ä¸‹
      fireEvent.drop(dropzone, createDragEventData([file]));
      
      await waitFor(() => {
        expect(mockOnFilesChange).toHaveBeenCalledWith([
          expect.objectContaining({ name: 'dragged.png' })
        ]);
      });
    });

    it('æ‹–æ‹½ç¦»å¼€æ—¶åº”è¯¥å–æ¶ˆæ¿€æ´»çŠ¶æ€', () => {
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const dropzone = screen.getByText(/æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ /).closest('div')!;
      
      fireEvent.dragEnter(dropzone);
      expect(dropzone).toHaveClass('active');
      
      fireEvent.dragLeave(dropzone);
      expect(dropzone).not.toHaveClass('active');
    });

    it('åº”è¯¥é˜»æ­¢æ‹–æ‹½äº‹ä»¶çš„é»˜è®¤è¡Œä¸º', () => {
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const dropzone = screen.getByText(/æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ /).closest('div')!;
      const preventDefault = vi.fn();
      
      fireEvent.dragOver(dropzone, { preventDefault });
      expect(preventDefault).toHaveBeenCalled();
    });
  });

  describe('æ–‡ä»¶éªŒè¯', () => {
    it('åº”è¯¥æ‹’ç»è¶…è¿‡å¤§å°é™åˆ¶çš„æ–‡ä»¶', async () => {
      const user = userEvent.setup();
      render(<FileUpload maxSize={1000} onFilesChange={mockOnFilesChange} />);
      
      const largeFile = createMockFile('large.png', 2000, 'image/png');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      // æ¨¡æ‹Ÿ window.alert
      const alertMock = vi.spyOn(window, 'alert').mockImplementation(() => {});
      
      await user.upload(fileInput, largeFile);
      
      expect(alertMock).toHaveBeenCalledWith(
        expect.stringContaining('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡')
      );
      expect(mockOnFilesChange).not.toHaveBeenCalled();
      
      alertMock.mockRestore();
    });

    it('åº”è¯¥æ‹’ç»ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹', async () => {
      const user = userEvent.setup();
      render(<FileUpload accept="image/*" onFilesChange={mockOnFilesChange} />);
      
      const invalidFile = createMockFile('test.pdf', 1024, 'application/pdf');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      const alertMock = vi.spyOn(window, 'alert').mockImplementation(() => {});
      
      await user.upload(fileInput, invalidFile);
      
      expect(alertMock).toHaveBeenCalledWith(
        expect.stringContaining('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹')
      );
      expect(mockOnFilesChange).not.toHaveBeenCalled();
      
      alertMock.mockRestore();
    });

    it('åº”è¯¥æ¥å—ç¬¦åˆæ‰©å±•åçš„æ–‡ä»¶', async () => {
      const user = userEvent.setup();
      render(<FileUpload accept=".pdf,.jpg" onFilesChange={mockOnFilesChange} />);
      
      const validFile = createMockFile('test.pdf', 1024, 'application/pdf');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, validFile);
      
      expect(mockOnFilesChange).toHaveBeenCalled();
    });

    it('åº”è¯¥åŒæ—¶å¤„ç†æœ‰æ•ˆå’Œæ— æ•ˆæ–‡ä»¶', async () => {
      const user = userEvent.setup();
      render(<FileUpload accept="image/*" maxSize={1500} onFilesChange={mockOnFilesChange} />);
      
      const files = [
        createMockFile('valid.png', 1024, 'image/png'), // æœ‰æ•ˆ
        createMockFile('invalid.pdf', 1024, 'application/pdf'), // ç±»å‹æ— æ•ˆ
        createMockFile('large.jpg', 2000, 'image/jpeg') // å¤§å°æ— æ•ˆ
      ];
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      const alertMock = vi.spyOn(window, 'alert').mockImplementation(() => {});
      
      await user.upload(fileInput, files);
      
      // åº”è¯¥åªè°ƒç”¨ä¸€æ¬¡ï¼ŒåŒ…å«æœ‰æ•ˆæ–‡ä»¶
      expect(mockOnFilesChange).toHaveBeenCalledWith([
        expect.objectContaining({ name: 'valid.png' })
      ]);
      expect(alertMock).toHaveBeenCalled();
      
      alertMock.mockRestore();
    });
  });

  describe('æ–‡ä»¶åˆ—è¡¨ç®¡ç†', () => {
    it('åº”è¯¥æ˜¾ç¤ºä¸Šä¼ çš„æ–‡ä»¶åˆ—è¡¨', async () => {
      const user = userEvent.setup();
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const file = createMockFile('test.png', 1024, 'image/png');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, file);
      
      expect(screen.getByText('å·²ä¸Šä¼ æ–‡ä»¶ (1)')).toBeInTheDocument();
      expect(screen.getByText('test.png')).toBeInTheDocument();
      expect(screen.getByText('1 KB')).toBeInTheDocument();
    });

    it('åº”è¯¥æ”¯æŒåˆ é™¤æ–‡ä»¶', async () => {
      const user = userEvent.setup();
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const files = [
        createMockFile('test1.png', 1024, 'image/png'),
        createMockFile('test2.jpg', 2048, 'image/jpeg')
      ];
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, files);
      
      // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ–‡ä»¶çš„åˆ é™¤æŒ‰é’®
      const removeButtons = screen.getAllByLabelText(/åˆ é™¤/);
      await user.click(removeButtons[0]);
      
      // åº”è¯¥è°ƒç”¨ onFilesChange å¹¶ç§»é™¤ç¬¬ä¸€ä¸ªæ–‡ä»¶
      expect(mockOnFilesChange).toHaveBeenLastCalledWith([
        expect.objectContaining({ name: 'test2.jpg' })
      ]);
      
      // åˆ—è¡¨åº”è¯¥æ›´æ–°
      expect(screen.getByText('å·²ä¸Šä¼ æ–‡ä»¶ (1)')).toBeInTheDocument();
      expect(screen.queryByText('test1.png')).not.toBeInTheDocument();
      expect(screen.getByText('test2.jpg')).toBeInTheDocument();
    });

    it('åˆ é™¤æ–‡ä»¶ååº”è¯¥æ›´æ–°å›è°ƒ', async () => {
      const user = userEvent.setup();
      const { rerender } = render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const file = createMockFile('test.png', 1024, 'image/png');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, file);
      
      // åˆ é™¤æ–‡ä»¶
      const removeButton = screen.getByLabelText(/åˆ é™¤ test\.png/);
      await user.click(removeButton);
      
      expect(mockOnFilesChange).toHaveBeenLastCalledWith([]);
      
      // é‡æ–°æ¸²æŸ“åæ–‡ä»¶åˆ—è¡¨åº”è¯¥ä¸ºç©º
      rerender(<FileUpload onFilesChange={mockOnFilesChange} />);
      expect(screen.queryByText('å·²ä¸Šä¼ æ–‡ä»¶')).not.toBeInTheDocument();
    });
  });

  describe('æ–‡ä»¶ç±»å‹å›¾æ ‡', () => {
    it('åº”è¯¥ä¸ºå›¾ç‰‡æ–‡ä»¶æ˜¾ç¤ºå›¾ç‰‡å›¾æ ‡', async () => {
      const user = userEvent.setup();
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const file = createMockFile('test.png', 1024, 'image/png');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, file);
      
      expect(screen.getByText('ğŸ–¼ï¸')).toBeInTheDocument();
    });

    it('åº”è¯¥ä¸ºPDFæ–‡ä»¶æ˜¾ç¤ºæ–‡æ¡£å›¾æ ‡', async () => {
      const user = userEvent.setup();
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const file = createMockFile('test.pdf', 1024, 'application/pdf');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, file);
      
      expect(screen.getByText('ğŸ“„')).toBeInTheDocument();
    });

    it('åº”è¯¥ä¸ºæœªçŸ¥ç±»å‹æ˜¾ç¤ºé»˜è®¤å›¾æ ‡', async () => {
      const user = userEvent.setup();
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const file = createMockFile('test.xyz', 1024, 'application/xyz');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      await user.upload(fileInput, file);
      
      expect(screen.getByText('ğŸ“')).toBeInTheDocument();
    });
  });

  describe('è¾¹ç¼˜æƒ…å†µ', () => {
    it('ç©ºæ–‡ä»¶é€‰æ‹©ä¸åº”è¯¥è§¦å‘å›è°ƒ', async () => {
      const user = userEvent.setup();
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      // è§¦å‘ change äº‹ä»¶ä½†æ²¡æœ‰æ–‡ä»¶
      fireEvent.change(fileInput, { target: { files: [] } });
      
      expect(mockOnFilesChange).not.toHaveBeenCalled();
    });

    it('æ‹–æ‹½ç©ºæ–‡ä»¶ä¸åº”è¯¥è§¦å‘å›è°ƒ', () => {
      render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const dropzone = screen.getByText(/æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ /).closest('div')!;
      
      fireEvent.drop(dropzone, createDragEventData([]));
      
      expect(mockOnFilesChange).not.toHaveBeenCalled();
    });

    it('ç»„ä»¶å¸è½½åä¸åº”è¯¥è°ƒç”¨å›è°ƒ', async () => {
      const user = userEvent.setup();
      const { unmount } = render(<FileUpload onFilesChange={mockOnFilesChange} />);
      
      const file = createMockFile('test.png', 1024, 'image/png');
      const fileInput = screen.getByLabelText(/é€‰æ‹©æ–‡ä»¶/) as HTMLInputElement;
      
      unmount();
      
      await user.upload(fileInput, file);
      
      expect(mockOnFilesChange).not.toHaveBeenCalled();
    });
  });
});
